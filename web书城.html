<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
	<meta name="format-detection" content="telephone=no">
	<link rel="stylesheet" type="text/css" href="reset.css">
	<link rel="stylesheet" type="text/css" href="main.css">
	<title>Web 书城</title>
	<style type="text/css">
	</style>
</head>
<body>
	<div id="root" class="container">
		<header id="top-nav"  style="display: none;">
			<div id="icon-back"></div>
			<div id="js-nav-title" class="nav-title">返回封面</div>
			
		</header>
		<div class="m-artical-action">
			<div class="artical-action-mid" id="action-mid"></div>
		</div>
		<div id="fiction-container" class="m-read-content">
			<h4>Chapter 1: Asynchrony: Now &amp; Later</h4>

<p>One of the most important and yet often misunderstood parts of programming in a language like JavaScript is how to express and manipulate program behavior spread out over a period of time.</p>

<p>This is not just about what happens from the beginning of a <code>for</code> loop to the end of a <code>for</code> loop, which of course takes <em>some time</em> (microseconds to milliseconds) to complete. It&#39;s about what happens when part of your program runs <em>now</em>, and another part of your program runs <em>later</em> -- there&#39;s a gap between <em>now</em> and <em>later</em> where your program isn&#39;t actively executing.</p>

<p>Practically all nontrivial programs ever written (especially in JS) have in some way or another had to manage this gap, whether that be in waiting for user input, requesting data from a database or file system, sending data across the network and waiting for a response, or performing a repeated task at a fixed interval of time (like animation). In all these various ways, your program has to manage state across the gap in time. As they famously say in London (of the chasm between the subway door and the platform): &quot;mind the gap.&quot;</p>

<p>In fact, the relationship between the <em>now</em> and <em>later</em> parts of your program is at the heart of asynchronous programming.</p>

<p>Asynchronous programming has been around since the beginning of JS, for sure. But most JS developers have never really carefully considered exactly how and why it crops up in their programs, or explored various <em>other</em> ways to handle it. The <em>good enough</em> approach has always been the humble callback function. Many to this day will insist that callbacks are more than sufficient.</p>

<p>But as JS continues to grow in both scope and complexity, to meet the ever-widening demands of a first-class programming language that runs in browsers and servers and every conceivable device in between, the pains by which we manage asynchrony are becoming increasingly crippling, and they cry out for approaches that are both more capable and more reason-able.</p>

<p>While this all may seem rather abstract right now, I assure you we&#39;ll tackle it more completely and concretely as we go on through this book. We&#39;ll explore a variety of emerging techniques for async JavaScript programming over the next several chapters.</p>

<p>But before we can get there, we&#39;re going to have to understand much more deeply what asynchrony is and how it operates in JS.</p>
<p>You may write your JS program in one <em>.js</em> file, but your program is almost certainly comprised of several chunks, only one of which is going to execute <em>now</em>, and the rest of which will execute <em>later</em>. The most common unit of <em>chunk</em> is the <code>function</code>.</p>

<p>The problem most developers new to JS seem to have is that <em>later</em> doesn&#39;t happen strictly and immediately after <em>now</em>. In other words, tasks that cannot complete <em>now</em> are, by definition, going to complete asynchronously, and thus we will not have blocking behavior as you might intuitively expect or want.</p>

<p>Consider:</p>

<p><code></code>`js
// ajax(..) is some arbitrary Ajax function given by a library
var data = ajax( &quot;http://some.url.1&quot; );</p>

<p>console.log( data );
// Oops! <code>data</code> generally won&#39;t have the Ajax results
<code></code>`</p>

<p>You&#39;re probably aware that standard Ajax requests don&#39;t complete synchronously, which means the <code>ajax(..)</code> function does not yet have any value to return back to be assigned to <code>data</code> variable. If <code>ajax(..)</code> <em>could</em> block until the response came back, then the <code>data = ..</code> assignment would work fine.</p>

<p>But that&#39;s not how we do Ajax. We make an asynchronous Ajax request <em>now</em>, and we won&#39;t get the results back until <em>later</em>.</p>

<p>The simplest (but definitely not only, or necessarily even best!) way of &quot;waiting&quot; from <em>now</em> until <em>later</em> is to use a function, commonly called a callback function:</p>

<p><code></code>`js
// ajax(..) is some arbitrary Ajax function given by a library
ajax( &quot;http://some.url.1&quot;, function myCallbackFunction(data){</p>

<pre><code>console.log( data ); // Yay, I gots me some `data`!</code></pre>

<p>} );
<code></code>`</p>

<p><strong>Warning:</strong> You may have heard that it&#39;s possible to make synchronous Ajax requests. While that&#39;s technically true, you should never, ever do it, under any circumstances, because it locks the browser UI (buttons, menus, scrolling, etc.) and prevents any user interaction whatsoever. This is a terrible idea, and should always be avoided.</p>

<p>Before you protest in disagreement, no, your desire to avoid the mess of callbacks is <em>not</em> justification for blocking, synchronous Ajax.</p>

<p>For example, consider this code:</p>

<p><code></code>`js
function now() {
	return 21;
}</p>

<p>function later() {
	answer = answer * 2;
	console.log( &quot;Meaning of life:&quot;, answer );
}</p>

<p>var answer = now();</p>

<p>setTimeout( later, 1000 ); // Meaning of life: 42
<code></code>`</p>

<p>There are two chunks to this program: the stuff that will run <em>now</em>, and the stuff that will run <em>later</em>. It should be fairly obvious what those two chunks are, but let&#39;s be super explicit:</p>

<p>Now:
<code></code>`js
function now() {
	return 21;
}</p>

<p>function later() { .. }</p>

<p>var answer = now();</p>

<p>setTimeout( later, 1000 );
<code></code>`</p>

<p>Later:
<code>js
answer = answer * 2;
console.log( &quot;Meaning of life:&quot;, answer );
</code></p>

<p>The <em>now</em> chunk runs right away, as soon as you execute your program. But <code>setTimeout(..)</code> also sets up an event (a timeout) to happen <em>later</em>, so the contents of the <code>later()</code> function will be executed at a later time (1,000 milliseconds from now).</p>

<p>Any time you wrap a portion of code into a <code>function</code> and specify that it should be executed in response to some event (timer, mouse click, Ajax response, etc.), you are creating a <em>later</em> chunk of your code, and thus introducing asynchrony to your program.</p>



			<ul class="tab">
			<li id="prev-btn">上一章</li>
			<li id="next-btn">下一章</li>

			</ul>
		</div>
		 <div id="panel-container" style="display: none;"  >
			<div class="child-mod" id="font-control">
				<span>字体</span>
				<button id="large">大</button>
				<button id="small">小</button>
			</div>
			<div class="child-mod" id="bg-control">
				<span>背景</span>
				<div  id="color1" class="bg-container" data-color="#f0f8f8">
					
				</div>
				<div id="color2" class="bg-container" data-color="#e9dfc7">
					
				</div>
				<div id="color3" class="bg-container" data-color="#c7edcc">
					
				</div>
				<div id="color4" class="bg-container" data-color="#f8c3cd" data-font="#f5f5f5">
					
				</div>
				<div id="color5" class="bg-container" data-color="#333333" data-font="#e6e6fa">
					
				</div>
			</div>
		</div>
		<div id="footer-bg"  class="bottom-nav" style="display: none;"></div>
		<footer id="bottom-nav" class="bottom-nav" style="display: none;">
			<div class="itembutton">
				<div class="wrapper">
					<div id="icon-menu"></div>
					<div class="icon-text">目录</div>
				</div>
			</div>
			<div class="itembutton">
				<div class="wrapper" id="font">
			
					<div id="icon-font"></div>

					
					<div class="icon-text">字体</div>
				</div>
			</div>
			<div class="itembutton">
				<div class="wrapper" id="moon-sun">
			
					<div id="moon-container">
						<div id="icon-night"></div>
						<div class="icon-text">夜间</div>
					</div>
					<div id="sun-container" style="display: none;">

						<div id="icon-day"></div>
						<div class="icon-text">白天</div>
					</div>
				</div>
			</div>
		</footer>
	</div>
</body>
<script type="text/javascript" src="lib\zepto.min.js"></script>
<script type="text/javascript" >
	window.jQuery = $;
</script>
<script type="text/javascript" src="lib\jquery.base64.js"></script>
<script type="text/javascript" src="lib\jquery.jsonp.js"></script>
<script type="text/javascript">
	(function(){
		var win=$(window);
			var Dom = {
					top_nav: $('#top-nav'),
					bottom_nav:$('.bottom-nav'),
					font:$('#font'),
					pannel_control:$('#panel-container'),
					moon_sun:$('#moon-sun'),
					sun:$('#sun-container'),
					moon:$('#moon-container'),
					fiction_area:$('#fiction_container'),
					// fiction_word:$('#fiction_word'),
					color1:$('#color1'),
					color2:$('#color2'),
					color3:$('#color3'),
					color4:$('#color4'),
					bg_control:$('#bg-control'),
					color5:$('#color5'),
					note_container:('#note-container')
				};
			var RootContainer = $('#fiction_container');

			var Fiction_id, Chapter_id;

				
		var Store=(function(){
			//localstorage
			var prefix='reader'
			var StorageGetter=function(key){
				return localStorage.getItem(prefix+key);

			}
			var StorageSetter=function(key,val){
				return localStorage.setItem(prefix+key ,val);

			}
			function getBSONP(url, callback) {
						return $.jsonp({
							url : url,
							cache : true,
							callback : "html_fiction_chapter",
							success : function(result) {
								var data = $.base64.decode(result);
								var json = decodeURIComponent(escape(data));
								callback(json);
							}
						});

					};

			
					
			return{
				getBSONP : getBSONP,
				StorageGetter:StorageGetter,
				StorageSetter:StorageSetter
			}
		})();
	
		var initFontSizeP=Store.StorageGetter('FontSizeP');
				initFontSizeP=parseInt(initFontSizeP);
				if(!initFontSizeP){
					initFontSizeP=14;
				}
				$('#fiction-container p').css('font-size',initFontSizeP);

		var initFontSizeH=Store.StorageGetter('FontSizeH');
				initFontSizeH=parseInt(initFontSizeH);
				if(!initFontSizeH){
					initFontSizeH=20;
				}
				$('#fiction-container h4').css('font-size',initFontSizeH);
		var color=Store.StorageGetter('background_color');
		var font=Store.StorageGetter('font_color');
		$('body').css('background-color',color);
		$('.m-read-content').css('color',font);
					
			

		function Main(){
			//入口

			EventHandler();
		}
		function UIDraw(){
			//UIxuanran
			function parseChapterData(jsonData) {
						var jsonObj = JSON.parse(jsonData);
						var html = "<h4>" + jsonObj.t + "</h4>";
						for (var i = 0; i < jsonObj.p.length; i++) {
							html += "<p>" + jsonObj.p[i] + "</p>";
						}
						return html;
					}

					return function(data) {
						container.html(parseChapterData(data));
					};
		}
		function DataMdules(id_, cid_, onChange_){
			//数据
			var Title = "";

					var Fiction_id = id_;

					var Chapter_id = cid_;

					if (Util.StorageGetter(Fiction_id + 'last_chapter')) {
						Chapter_id = Util.StorageGetter(Fiction_id + 'last_chapter');
					}

					if (!Chapter_id) {
						Chapter_id = 1;
					}
					var Chapters = [];

					var init = function() {
						getFictionInfoPromise.then(function(d) {
							gotoChapter(Chapter_id);
						});
					
					}
					var gotoChapter = function(chapter_id) {
						Chapter_id = chapter_id;
						getCurChapterContent();
					};

					//获得当前章节内容
					var getCurChapterContent = function() {
						$.get("data/data" + Chapter_id + ".json", function(data) {

							if (data.result == 0) {
								var url = data.jsonp;
								Util.getBSONP(url, function(data) {
									$('#init_loading').hide();
									onChange_ && onChange_(data);
								});
							} else {

							}
						}, 'json');
						return;

					};

					var getFictionInfoPromise = new Promise(function(resolve, reject) {
						$.get("data/chapter.json", function(data) {
							if (data.result == 0) {
								Title = data.title;
								$('#nav_title').html('返回书架');
								window.ChaptersData = data.chapters;
								window.chapter_data = data.chapters;
								for (var i = 0; i < data.chapters.length; i++) {
									Chapters.push({
										"chapter_id" : data.chapters[i].chapter_id,
										"title" : data.chapters[i].title
									})
								}
								resolve(Chapters);
							} else {
								reject(data);
							}
						}, 'json');
					});
					//获得上一章内容
					var prevChapter = function() {
						Chapter_id = parseInt(Chapter_id);
						if (Chapter_id == 0) {
							return
						}
						var cid = Chapter_id - 1;
						gotoChapter(cid);
						Util.StorageSetter(Fiction_id + 'last_chapter', Chapter_id);
					};

					//获得下一章内容
					var nextChapter = function() {
						Chapter_id = parseInt(Chapter_id);
						if (Chapter_id == Chapters.length - 1) {
							return
						}
						var cid = Chapter_id + 1;
						gotoChapter(cid);
						Util.StorageSetter(Fiction_id + 'last_chapter', Chapter_id);
					};

					return {
						init : init,
						go : gotoChapter,
						prev : prevChapter,
						next : nextChapter,
						getChapter_id : function() {
							return Chapter_id;
						}
					};

		}
		function EventHandler(){
			//事件绑定

			$('#action-mid').click(function(){
				if (Dom.top_nav.css('display')=='none') {
					Dom.top_nav.show();
					Dom.bottom_nav.show();

				}
				else{
					Dom.top_nav.hide();
					Dom.bottom_nav.hide();
					Dom.pannel_control.hide();
				}

			});
			Dom.font.click(function(){
				if(Dom.pannel_control.css('display')=='none'){
					Dom.pannel_control.show();
					


				}
				else{
					Dom.pannel_control.hide();

				}
			});
			win.scroll(function(){
				Dom.top_nav.hide();
					Dom.bottom_nav.hide();
					Dom.pannel_control.hide();
				
			});
			var moonsun=Dom.moon_sun.click(function(){
			
				if(Dom.sun.css('display')=='none'){
					Dom.sun.show();
					Dom.moon.hide();
					Dom.color5.trigger('click');



				}
				else{
					Dom.sun.hide();
					Dom.moon.show();
					Dom.color2.trigger('click');


				}
			});
			//背景色
		
				Dom.bg_control.delegate('.bg-container','click',function(){
					var color= $(this).data('color');
					var font=$(this).data('font');
					if(!font){
						font='#000';
					}
					$('body').css('background-color',color);
					$('.m-read-content').css('color',font);
					Store.StorageSetter('background_color',color);
					Store.StorageSetter('font_color',font);


					
				
				});

					
			$('#large').click(function(){
				if(initFontSizeP>20){
					return;
				}
				 if(initFontSizeH>26){
					return;
				}
				initFontSizeP+=1;
				initFontSizeH+=1;
				$('#fiction-container p').css('font-size',initFontSizeP);
				Store.StorageSetter('FontSizeP',initFontSizeP);

				$('#fiction-container h4').css('font-size',initFontSizeH);


				Store.StorageSetter('FontSizeH',initFontSizeH);


			});
			$('#small').click(function(){
				if(initFontSizeP<10){
					return;
				}
				 if(initFontSizeH<14){
					return;
				}
				initFontSizeP-=1;
				initFontSizeH-=1;
				$('#fiction-container p').css('font-size',initFontSizeP);
				Store.StorageSetter('FontSizeP',initFontSizeP);

				$('#fiction-container h4').css('font-size',initFontSizeH);


				Store.StorageSetter('FontSizeH',initFontSizeH);


			});




		}
		Main();

	})();
</script>
</html>